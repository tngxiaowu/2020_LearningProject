// 楼梯一共n阶 然后每次都走1或2步 请问一共有多少种走法?
// 比如说 如有有3阶 那么一共有 1+1 1+1+1 2+1 三种做法

// 动态规划的解题思路
// 1. 定位到问题的终点
// 2. 站在终点这个视角 思考后退的可能


// 我们假设f(n)是 走到第n阶楼梯 对应的 路径数
// 并且每次只能后退一步 或者 两步
// 所以基本的逻辑如下
f(n) = fn(n-1) + f(n-2);

// f(n-1)为抵达 第n-1阶 楼梯对应的路径数
// f(n-2)为抵达 第n-2阶 楼梯对应的路径数

// 如果 n = 3  -> f(3) = f(2) + f(1) 
// f(2)为抵达 第二阶 所需的台阶数
// f(1)为抵达 第一阶 所需的台阶数



let f1 = 1; // 第一阶是第一步
let f2 = 2; // 第二阶是第二步


const f = []

const climbStands = n => {
    // 处理边界问题
    if(n === 1){
        return 1;
    }
    if(n === 2){
        return 2;
    }
    // 递归计算
    if(f[n] === undefined) f[n] = climbStands(n-1) + climbStands(n-2)

    return f[n]
}

climbStands(3);

// 112 121  211     22 1111 


// 动态规范解法

const climbStairs = n => {
    // 初始化状态数组
    const f = []; 
    
    // 初始化已知值
    f[1] = 1; 
    f[2] = 2;

    // 动态更新每一层楼梯对应的结果
    for(let i = 3;i <= n;i++){
        f[i] = f[i-2] + f[i-1];
    }
    // 返回目标值
    return f[n];
};

climbStairs(4);

// 优雅地找硬币
// 找出凑成总金额所需的最少硬币个数
const coins = [1,2,5], amount = 11;

// 找到问题终点 思考倒退姿势 
// 明确状态转移方程
// 将递归代码转换为迭代表达

// n美元
// n - c1 / n - c2 / n - c3 


// 11
// 11 - 1       / 11 - 2        / 11 - 5
// 11 - 1 - 1 / 11 - 1 - 2 // 11 - 1 - 5 

// 假设f(x)表示每一个总额数字对应的最少硬币数

f(36) = Math.min( f(36-c1)+1, f(36-c2)+1, ... , f(36-cn)+1)



const coinChange = (coins, amount) => {
    // 用于保存每个目标总额对应的最小硬币个数
    const f = []
    // 提前定义已知情况
    f[0] = 0
    // 遍历 [1, amount] 这个区间的硬币总额
    for(let i=1;i<=amount;i++) {
        // 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新
        f[i] = Infinity
        // 循环遍历每个可用硬币的面额
        for(let j=0;j<coins.length;j++) {
            // 若硬币面额小于目标总额，则问题成立
            if(i-coins[j]>=0) {
                // 状态转移方程
                f[i] = Math.min(f[i],f[i-coins[j]]+1)
            }
        }
    }
    // 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1
    if(f[amount]===Infinity) {
        return -1
    }
    // 若有解，直接返回解的内容
    return f[amount]
};

